/* Minijava Grammar */
import errors.GestionErroresTiny;

import java_cup.runtime.*;
import java_cup.runtime.ComplexSymbolFactory;
import java_cup.runtime.ScannerBuffer;
import java_cup.runtime.XMLElement;
import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamWriter;
import java.io.*;

import javax.xml.transform.*;
import javax.xml.transform.stream.*;

parser code {:  
	private static final String INPUT_FILE       = "input.txt";
	private static final String XML_OUTPUT_FILE  = "output/parser1.xml";
	private static final String HTML_OUTPUT_FILE = "ast.html";
	private static final String TMP_OUTPUT_FILE  = "output/parser2.xml";
	private static final String TRANSFORM_1      = "configs/tree.xsl";
	private static final String TRANSFORM_2      = "configs/tree-view.xsl";
	
    private GestionErroresTiny errores = new GestionErroresTiny();


  public Parser(Lexer lex, ComplexSymbolFactory sf) {
    super(lex,sf);
  }
  public static void main(String[] args) throws Exception {
  
  	  // Parser initialization
      ComplexSymbolFactory csf = new ComplexSymbolFactory();
      ScannerBuffer lexer = new ScannerBuffer(new Lexer(new BufferedReader(new FileReader(INPUT_FILE)),csf));
      Parser p = new Parser(lexer,csf);
      
      // Parser to XML format
      XMLElement e = (XMLElement)p.parse().value;

      for (XMLElement el: SyntaxTreeXPath.query("/",e)){
      	  System.out.println(el.getTagname());
      }


      TestVisitor t = new TestVisitor();
      SyntaxTreeDFS.dfs(e,t);

      // create XML output file 
      XMLOutputFactory outFactory = XMLOutputFactory.newInstance();
      XMLStreamWriter sw = outFactory.createXMLStreamWriter(new FileOutputStream(XML_OUTPUT_FILE));
      XMLElement.dump(lexer,sw,e,"expr","stmt");
      
       // XML to human viewable format (HTML in this case)
      Transformer transformer = TransformerFactory.newInstance().newTransformer(new StreamSource(new File(TRANSFORM_1)));
      Source text = new StreamSource(new File(XML_OUTPUT_FILE));
      transformer.transform(text, new StreamResult(new File(TMP_OUTPUT_FILE)));
      transformer = TransformerFactory.newInstance().newTransformer(new StreamSource(new File(TRANSFORM_2)));
      text = new StreamSource(new File(TMP_OUTPUT_FILE));
      transformer.transform(text, new StreamResult(new File("ast.html")));

      System.out.println("AST generation succeed");
  }
:}; 

terminal	IDEN, ENT, MAS, MENOS, POR, DIV, IGUAL, AMPERSAND, MAIN, 
			COMA, PAP, PCIERRE, CAP, CCIERRE, LLAP, LLCIERRE, NULL,
			AND, OR, NOT, MAYOR, MENOR, MAYORIGUAL, MENORIGUAL, PUNTO,
			DISTINTO, IGUALIGUAL, IF, ELSE, WHILE, PUNTOCOMA, DOSPUNTOS, 
			INT, BOOL, TRUE, FALSE, RETURN, SWITCH, CASE, DEFAULT, VOID;

non terminal	S, FunsProcs, main, Funcion, Procedimiento, Llamada, Instruccion,
                Instrucciones, Asignacion, Declaracion, If, IfElse, While, 
                Invoke, Switch, AccesoVariable, Acceso, Case, Cases, Default,
				Argumentos, Args, DefArgumentos, Bloque, BloqueReturn, Tipo, 
                Tipos, TipoIden, TiposIdens, E0, E1, E2, E3, E4, Op0, Op1, Op2, Op3 ;

// Estructura de un programa: definiciones de funciones/procedimientos y una función main.
S ::= FunsProcs main ;

FunsProcs ::= FunsProcs Funcion | FunsProcs Procedimiento | ;
main ::= INT MAIN PAP PCIERRE BloqueReturn ;

// Declaración de funciones y procedimientos
Funcion ::= TipoIden PAP DefArgumentos PCIERRE BloqueReturn ;
Procedimiento ::= VOID IDEN PAP DefArgumentos PCIERRE Bloque ;

DefArgumentos ::= TiposIdens | ;

// Instrucciones permitidas
Instruccion ::= Asignacion | Declaracion | If | IfElse | While | Llamada | Switch ;
Asignacion ::= AccesoVariable IGUAL E0 PUNTOCOMA ;
Declaracion ::= TipoIden PUNTOCOMA | TipoIden IGUAL E0 PUNTOCOMA ;
If ::= IF PAP E0 PCIERRE Bloque ;
IfElse ::= If ELSE Bloque ;
While ::= WHILE PAP E0 PCIERRE Bloque ;
Invoke ::= IDEN PAP Argumentos PCIERRE ;
Llamada ::= Invoke PUNTOCOMA ;
Switch ::= SWITCH PAP E0 PCIERRE LLAP Cases LLCIERRE |
           SWITCH PAP E0 PCIERRE LLAP Cases Default LLCIERRE ;                  

AccesoVariable ::= IDEN Acceso ;
Acceso ::= Acceso CAP E0 CCIERRE | Acceso PUNTO ENT | ;

Cases ::= Cases Case | ;
Case ::= CASE E0 DOSPUNTOS Bloque ;
Default ::= DEFAULT DOSPUNTOS Bloque ; 

Argumentos ::= Args | ;
Args ::=  Args COMA E0 | E0 ;

// Bloques de instrucciones 
Instrucciones ::= Instrucciones Instruccion | ;
Bloque ::= LLAP Instrucciones LLCIERRE ;
BloqueReturn ::= LLAP Instrucciones RETURN E0 PUNTOCOMA LLCIERRE ;

// Tipos permitidos
Tipo ::= INT | BOOL | CAP Tipo COMA ENT CCIERRE | POR Tipo | MENOR Tipos MAYOR ;
Tipos ::= Tipos COMA Tipo | Tipo ;
TipoIden ::= Tipo IDEN ;
TiposIdens ::= TiposIdens COMA TipoIden | TipoIden ;

// Expresiones, operadores y prioridades
E0 ::= E1 Op0 E1 | E1 ;
E1 ::= E1 Op1 E2 | E2 ;
E2 ::= E2 Op2 E3 | E3 ;
E3 ::= Op3 E3 | E4 ;
E4 ::= ENT | TRUE | FALSE | NULL | PAP E0 PCIERRE | AccesoVariable | Invoke ;
Op0 ::= IGUALIGUAL | DISTINTO | MAYOR | MENOR | MENORIGUAL | MAYORIGUAL ;
Op1 ::= MAS | MENOS | OR ;
Op2 ::= POR | DIV | AND ;
Op3 ::= MENOS | NOT | AMPERSAND ;


