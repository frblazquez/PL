package asint;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;

import java_cup.runtime.*;
import ast.*;
import ast.types.*;
import ast.expressions.*;
import ast.instructions.*;
import ast.instructions.access.*;
import alex.UnidadLexica;
import alex.AnalizadorLexicoTiny;
import errors.GestionErroresTiny;

scan with {: return getScanner().next_token(); :};
parser code {: 
   private GestionErroresTiny errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErroresTiny();
   AnalizadorLexicoTiny alex = (AnalizadorLexicoTiny)getScanner();
   alex.fijaGestionErrores(errores);
:};

terminal	MAS, MENOS, POR, DIV, IGUAL, AMPERSAND, MAIN, 
			COMA, PAP, PCIERRE, CAP, CCIERRE, LLAP, LLCIERRE, NULL,
			AND, OR, NOT, MAYOR, MENOR, MAYORIGUAL, MENORIGUAL, PUNTO,
			DISTINTO, IGUALIGUAL, IF, ELSE, WHILE, PUNTOCOMA, DOSPUNTOS, 
			INT, BOOL, TRUE, FALSE, RETURN, SWITCH, CASE, DEFAULT, VOID;

terminal String IDEN ;
terminal String ENT;

non terminal Program S ;
non terminal List<Procedure> Metodos ;
non terminal Procedure Procedimiento;
non terminal Function Funcion ;
non terminal Function Main ;
non terminal Instructions Instrucciones;
non terminal Instructions Bloque;
non terminal Instruction Instruccion;
non terminal HashMap<String, Type> TiposIdens;
non terminal Type Tipo;
non terminal List<Type> Tipos;
non terminal HashMap<String, Type> DefArgumentos;
non terminal List<Expression> Argumentos;
non terminal List<Expression> Args;
non terminal Expression E0;
non terminal Expression E1;
non terminal Expression E2;
non terminal Expression E3;
non terminal Expression E4;
non terminal Call Llamada;
non terminal Call Invoke;
non terminal Assignment Asignacion;
non terminal Definition Declaracion;
non terminal IfElse If;
non terminal IfElse IfElse;
non terminal While While;
non terminal Switch Switch;
non terminal Case Case;
non terminal Case Default;
non terminal List<Case> Cases; 
non terminal String Op0;
non terminal String Op1;
non terminal String Op2;
non terminal String Op3;
non terminal VariableAccess AccesoVariable;
non terminal List<Access> Accesos;

// Estructura de un programa: definiciones de funciones/procedimientos y una función main.
S ::= Metodos:fp Main:mf {: RESULT = new Program(fp,mf); :};

//FunsProcs ::= FunsProcs Funcion | FunsProcs Procedimiento | ;
Metodos ::= Metodos:fp Funcion:f        {: RESULT = fp; fp.add(f); :} ;
Metodos ::= Metodos:fp Procedimiento:p  {: RESULT = fp; fp.add(p); :} ;
Metodos ::=                             {: RESULT = new ArrayList<Procedure>(); :} ;

// TODO: Revisar cuando los tipos y argumentos estén fijados
Main ::= INT MAIN PAP PCIERRE LLAP Instrucciones:ins RETURN E0:e PUNTOCOMA LLCIERRE 
        {: RESULT = new Function("main", null, ins, new IntType(), e); :};

// Declaración de funciones y procedimientos
Funcion ::= Tipo:t IDEN:id PAP DefArgumentos:args PCIERRE LLAP Instrucciones:ins RETURN E0:e PUNTOCOMA LLCIERRE			
			{: RESULT = new Function(id, args, ins, t, e); :};
Procedimiento ::= VOID IDEN:id PAP DefArgumentos:args PCIERRE Bloque:ins 	
			{: RESULT = new Procedure(id, args, ins); :};

DefArgumentos ::= TiposIdens | ;

// Instrucciones permitidas
Instruccion ::= Asignacion:ass 				{: RESULT = ass; :} 
			 	 | Declaracion:decl			{: RESULT = decl; :}
			 	 | If:iff					{: RESULT = iff; :} 
				 | IfElse:ifelse			{: RESULT = ifelse; :} 					
				 | While:wh					{: RESULT = wh; :} 
				 | Llamada:ll 				{: RESULT = ll; :}
				 | Switch:sw				{: RESULT = sw; :} ;

// TODO: Accesos a variables!

Asignacion ::= AccesoVariable:a IGUAL E0:e PUNTOCOMA        {: RESULT = new Assignment(a, e); :};
Declaracion ::= Tipo:t IDEN:id PUNTOCOMA                    {: RESULT = new Definition(t,id); :}
            |   Tipo:t IDEN:id IGUAL E0:e PUNTOCOMA         {: RESULT = new Definition(t,id,e); :};
If ::= IF PAP E0:e PCIERRE Bloque:ins                       {: RESULT = new IfElse(e,ins); :};
IfElse ::= IF PAP E0:e PCIERRE Bloque:bif ELSE Bloque:belse {: RESULT = new IfElse(e,bif,belse); :};
While ::= WHILE PAP E0:e PCIERRE Bloque:ins                 {: RESULT = new While(e,ins); :} ;
Invoke ::= IDEN:id PAP Argumentos:args PCIERRE              {: RESULT = new Call(id, args); :};
Llamada ::= Invoke:i PUNTOCOMA                              {: RESULT = i; :};
Switch ::= SWITCH PAP E0:e PCIERRE LLAP Cases:cs LLCIERRE               {: RESULT = new Switch(e,cs); :}
			| SWITCH PAP E0:e PCIERRE LLAP Cases:cs Default:d LLCIERRE  {: RESULT = new Switch(e,cs,d); :};                  

AccesoVariable ::= IDEN:id Accesos:as       {: RESULT = new VariableAccess(id, as); :};
Accesos ::= Accesos:as CAP E0:e CCIERRE     {: RESULT = as; as.add(new ArrayAccess(e)); :}
        |   Accesos:as PUNTO ENT:ent        {: RESULT = as; as.add(new RegisterAccess(Integer.parseInt(ent))); :}
        |                                   {: RESULT = new ArrayList<Access>(); :};

Cases ::= Cases:cs Case:c   {: RESULT = cs; cs.add(c); :}
        |                   {: RESULT = new ArrayList<Case>(); :};
Case ::= CASE E0:e DOSPUNTOS Bloque:ins     {: RESULT = new Case(e, ins); :};
Default ::= DEFAULT DOSPUNTOS Bloque:ins    {: RESULT = new Case(ins); :} ; 

Argumentos ::= Args:args        {: RESULT = args; :} 
            |                   {: RESULT = new ArrayList<Expression>(); :};
Args ::=  Args:args COMA E0:e   {: RESULT = args; args.add(e); :}     
            | E0:e              {: RESULT = new ArrayList<Expression>(); RESULT.add(e); :}   ;

// Bloques de instrucciones 
Instrucciones ::= Instrucciones:insts Instruccion:ins 	{: RESULT = insts; insts.add(ins); :} 
					| 									{: RESULT = new Instructions(); :};
Bloque ::= LLAP Instrucciones:insts LLCIERRE {: RESULT = insts; :};
//BloqueReturn ::= LLAP Instrucciones RETURN E0 PUNTOCOMA LLCIERRE ;

// Tipos permitidos
Tipo ::= INT                            {: RESULT = new IntType(); :}
    | BOOL                              {: RESULT = new BoolType(); :}
    | POR Tipo:t                        {: RESULT = new PointerType(t); :}
    | CAP Tipo:t COMA ENT:ent CCIERRE   {: RESULT = new ArrayType(t, Integer.parseInt(ent)); :}
    | MENOR Tipos:ts MAYOR              {: RESULT = new RegisterType(ts); :};
Tipos ::= Tipos:ts COMA Tipo:t      {: RESULT = ts; ts.add(t); :}
    | Tipo:t                        {: RESULT = new ArrayList<Type>(); RESULT.add(t); :};
//TipoIden ::= Tipo IDEN:nom {: RESULT = nom; :} ;
TiposIdens ::= TiposIdens:ti COMA Tipo:t IDEN:id   {: RESULT = ti; RESULT.put(id, t); :}    // TODO: Identificadores repetidos?(eso va en el codigo java)
            |  Tipo:t IDEN:id                   {: RESULT = new HashMap<String,Type>(); RESULT.put(id, t); :};

// Expresiones, operadores y prioridades
E0 ::= E1:expa Op0:op E1:expb 		{: RESULT = new Expression(op,2, new Expression[] {expa,expb} ); :}
		| E1:exp 					{: RESULT = exp; :};
E1 ::= E1:expa Op1:op E2:expb 		{: RESULT = new Expression(op,2, new Expression[] {expa, expb}); :}
		| E2:exp 					{: RESULT = exp; :};
E2 ::= E2:expa Op2:op E3:expb		{: RESULT = new Expression(op,2,new Expression[] {expa,expb}); :}  
		| E3:exp 					{: RESULT = exp; :};
E3 ::= Op3:op E3:exp	{: RESULT = new Expression(op, 1, new Expression[] {exp}); :}			   
		 | E4:exp		{: RESULT = exp; :} ;
E4 ::= ENT:str  {: RESULT = new Expression(str); :}
	| TRUE 		{: RESULT = new Expression("true"); :}
	| FALSE 	{: RESULT = new Expression("false"); :}
	| NULL 		{: RESULT = new Expression("null"); :}
	| PAP E0:exp PCIERRE {: RESULT = exp; :}
	| AccesoVariable {: RESULT = new Expression("accesovariable"); :} // TODO
	| Invoke {: RESULT = new Expression("invoke"); :};	// TODO
Op0 ::= MAYOR 		{: RESULT = ">"; :}
	| DISTINTO 		{: RESULT = "!="; :}
	| MENOR  		{: RESULT = "<"; :}
	| IGUALIGUAL 	{: RESULT = "=="; :}
	| MENORIGUAL 	{: RESULT = "<="; :}
	| MAYORIGUAL 	{: RESULT = ">="; :};
Op1 ::= MAS 		{: RESULT = "+"; :}
	| MENOS 		{: RESULT = "-"; :}
	| OR 			{: RESULT = "or"; :};	
Op2 ::= POR 		{: RESULT = "*"; :}
	| DIV 			{: RESULT = "\\"; :}
	| AND 			{: RESULT = "and"; :};
Op3 ::= MENOS 		{: RESULT = "-"; :}
	| NOT 			{: RESULT = "not"; :}
	| AMPERSAND 	{: RESULT = "&"; :};
